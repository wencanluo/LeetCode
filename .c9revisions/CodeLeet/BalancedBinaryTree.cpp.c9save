{"ts":1375376314898,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*Balanced Binary Tree Oct 9 '124862 / 11779\r\nGiven a binary tree, determine if it is height-balanced.\r\n\r\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\r\n\r\nAuthor: Wencan Luo\r\nLanguage: C++\r\nDate: 07/09/2013\r\n*/\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n#include<vector>\r\n#include<string>\r\n#include<algorithm>\r\n\r\n#include<map>\r\n//#include<unordered_set>\r\n\r\n#include<queue>\r\n#include<set>\r\n\r\n// Definition for binary tree\r\n struct TreeNode {\r\n     int val;\r\n     TreeNode *left;\r\n     TreeNode *right;\r\n TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n};\r\n \r\nclass Solution {\r\npublic:\r\n\tbool isBalancedRec_OnSpace(TreeNode *root, map<TreeNode *, pair<int, int>> &M){\r\n\t\tif(root == NULL) return true;\r\n\r\n\t\tif(M.find(root) == M.end()){\r\n\t\t\tM[root] = make_pair(0,0);\r\n\t\t}\r\n\r\n\t\tif(root->left == NULL){\r\n\t\t\tM[root].first = 0;\r\n\t\t}else{\r\n\t\t\tif(!isBalancedRec_OnSpace(root->left, M)) return false;\r\n\t\t}\r\n\r\n\t\tif(root->right == NULL){\r\n\t\t\tM[root].second = 0;\r\n\t\t}else{\r\n\t\t\tif(!isBalancedRec_OnSpace(root->right, M)) return false;\r\n\t\t}\r\n\r\n\t\tif(root->left != NULL){\r\n\t\t\tM[root].first = max(M[root->left].first, M[root->left].second) + 1;\r\n\t\t}\r\n\r\n\t\tif(root->right != NULL){\r\n\t\t\tM[root].second = max(M[root->right].first, M[root->right].second) + 1;\r\n\t\t}\r\n\r\n\t\tif(M[root].first - M[root].second > 1) return false;\r\n\t\tif(M[root].second - M[root].first > 1) return false;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tbool isBalancedRec(TreeNode *root, int *height){\r\n\t\tif(root == NULL){\r\n\t\t\t*height = 0;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tint leftheight = 0, rightheight = 0;\r\n\t\tif(!isBalancedRec(root->left, &leftheight)) return false;\r\n\t\tif(!isBalancedRec(root->right, &rightheight)) return false;\r\n\r\n\t\t*height = max(leftheight, rightheight) + 1;\r\n\t\tif(leftheight - rightheight > 1 || rightheight - leftheight > 1) return false;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tbool isBalanced(TreeNode *root) {\r\n\t\t// Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        if(root == NULL) return true;\r\n\t\tint height = 0;\r\n\t\treturn isBalancedRec(root, &height);\r\n\t}\r\n\r\n    bool isBalanced_OnSpace(TreeNode *root) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        if(root == NULL) return true;\r\n\r\n\t\tmap<TreeNode*, pair<int, int> > M;\r\n\t\treturn isBalancedRec_OnSpace(root, M);\r\n    }\r\n};\r\n\r\nvoid main(){\r\n\tSolution s;\r\n\t\r\n\tTreeNode a(1);\r\n\tTreeNode b(2);\r\n\tTreeNode c(3);\r\n\ta.right = &b;\r\n\ta.right = &c;\r\n\t//b.right = &c;\r\n\r\n\tcout << s.isBalanced(&a);\r\n\t//cout << s.minimumTotal(B);\r\n\tsystem(\"pause\");\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":2656}]],"length":2656}
