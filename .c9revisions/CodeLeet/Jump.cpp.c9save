{"ts":1375427987090,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\r\nJump Game\r\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\r\n\r\nEach element in the array represents your maximum jump length at that position.\r\n\r\nDetermine if you are able to reach the last index.\r\n\r\nFor example:\r\nA = [2,3,1,1,4], return true.\r\nA = [3,2,1,0,4], return false.\r\n\r\nAuthor: Wencan Luo\r\nLanguage: C++\r\nDate: 11/27/2012\r\nSolution: record the furtherst step that can reach\r\n*/\r\n\r\n#include<iostream>\r\n#include<vector>\r\n#include<queue>\r\nusing namespace std;\r\n\r\nclass Solution {\r\npublic:\r\n    bool canJump(int A[], int n) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        \r\n\t\tif(n <= 1) return true;\r\n\r\n\t\tint k = n-1;//last one\r\n\t\tfor(int i=n-2;i>=0;i--)\r\n\t\t{\r\n\t\t\tif(A[i] + i >= k) \r\n\t\t\t{\t\r\n\t\t\t\tk = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif( k == 0)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n    }\r\n\r\n\tclass PairCompare{\r\n\tpublic:\r\n\t\tbool operator()(pair<int,int> a, pair<int,int> b)\r\n\t\t{\r\n\t\t\tif( a.first <= b.first ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\tint jump(int A[], int n)//Greedy\r\n\t{\r\n\t\tif(n==1) return 0;\r\n\r\n\t\tint k=0;\r\n\t\tint jumps = 0;\r\n\t\tint curMax;\r\n\t\twhile(k < n)\r\n\t\t{\r\n\t\t\tcurMax = k + A[k];\r\n\r\n\t\t\tif(A[k] > 0) jumps++;\r\n\t\t\telse return -1;\r\n\r\n\t\t\tif(curMax >= n-1) return jumps;\r\n\r\n\t\t\tint tmpMax = 0;\r\n\r\n\t\t\tfor(int i=k+1;i<=curMax;i++)\r\n\t\t\t{\r\n\t\t\t\tif(A[i]+i >= tmpMax)\r\n\t\t\t\t{\r\n\t\t\t\t\tk = i;\r\n\t\t\t\t\ttmpMax = A[i]+i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn jumps;\r\n\t}\r\n\r\n\tint jumpBreath(int A[], int n)\r\n\t{\r\n\t\tif(!canJump(A,n)) return -1;\r\n\r\n\t\tif(n==1) return 0;\r\n\r\n\t\tqueue< pair<int,int> > q;\r\n\t\tvector< bool > visted;\r\n\t\tvisted.resize(n,false);\r\n\t\tq.push(make_pair(0,0));\r\n\r\n\t\twhile(!q.empty())\r\n\t\t{\r\n\t\t\tpair<int,int> p = q.front();\r\n\t\t\tq.pop();\r\n\t\t\tif(p.first==n-1){return p.second;}\r\n\r\n\t\t\tvisted[p.first] = true;\r\n\r\n\t\t\tfor(int i=p.first+1; i <= A[p.first] + p.first && i < n; i++)\r\n\t\t\t{\r\n\t\t\t\tif(!visted[i])\r\n\t\t\t\t{\r\n\t\t\t\t\tq.push(make_pair(i,p.second+1));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tint jumpDag(int A[], int n) {//Shortest distance for Dag\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n\t\tvector<int> s;\r\n\t\ts.resize(n,n+1);\r\n\r\n\t\ts[0] = 0;\r\n\t\tfor(int i=0;i<n;i++)\r\n\t\t{\r\n\t\t\tfor(int j=i+1; j <= i+A[i] && j < n; j++)\r\n\t\t\t{\r\n\t\t\t\ts[j] = min(s[j], s[i]+1);\r\n\t\t\t\tif(j==n-1)//reached the last one\r\n\t\t\t\t{\r\n\t\t\t\t\tif(s[n-1] <= n) return s[n-1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tif(s[n-1] > n) return -1;\r\n\t\treturn s[n-1];\r\n    }\r\n};\r\n\r\nvoid main()\r\n{\r\n\tSolution s;\r\n\tint A[] = {2,3,1,1,4};\r\n\tint d = s.jump(A, sizeof(A)/sizeof(A[0]));\r\n\r\n\tcout << d << endl;\r\n\tsystem(\"pause\");\r\n}"]],"start1":0,"start2":0,"length1":0,"length2":2656}]],"length":2656}
