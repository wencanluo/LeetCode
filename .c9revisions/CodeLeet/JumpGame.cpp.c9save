{"ts":1375404274132,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*Insert IntervalMar 27 '123940 / 13994\r\nGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\r\n\r\nYou may assume that the intervals were initially sorted according to their start times.\r\n\r\nExample 1:\r\nGiven intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].\r\n\r\nExample 2:\r\nGiven [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].\r\n\r\nThis is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].\r\n\r\nAuthor: Wencan Luo\r\nLanguage: C++\r\nDate: 08/01/2013\r\n*/\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n#include<climits>\r\n\r\n#include<vector>\r\n#include<string>\r\n#include<algorithm>\r\n\r\n#include<map>\r\n//#include<unordered_set>\r\n\r\n#include<queue>\r\n#include<set>\r\n\r\n// Definition for binary tree\r\n struct TreeNode {\r\n     int val;\r\n     TreeNode *left;\r\n     TreeNode *right;\r\n TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n};\r\n\r\n//Definition for singly-linked list.\r\nstruct ListNode {\r\n    int val;\r\n    ListNode *next;\r\n    ListNode(int x) : val(x), next(NULL) {}\r\n};\r\n\r\n// Definition for an interval.\r\nstruct Interval {\r\n    int start;\r\n    int end;\r\n    Interval() : start(0), end(0) {}\r\n    Interval(int s, int e) : start(s), end(e) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        vector<Interval> A;\r\n\t\tif(intervals.size() == 0){\r\n\t\t\tA.push_back(newInterval);\r\n\t\t\treturn A;\r\n\t\t}\r\n\r\n\t\tint k = 0;\r\n\t\tfor(int i=0; i<intervals.size();i++){\r\n\t\t\tif(intervals[i].end < newInterval.start){\r\n\t\t\t\tA.push_back(intervals[i]);\r\n\t\t\t\tk++;\r\n\t\t\t}else{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(k<intervals.size() && intervals[k].start < newInterval.start){\r\n\t\t\tnewInterval.start = intervals[k].start;\r\n\t\t}\t\t\r\n\r\n\t\tfor(int i=k; i<intervals.size();i++){\r\n\t\t\tif(intervals[i].start <= newInterval.end){\r\n\t\t\t\tk++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(k>0){\r\n\t\t\tif(intervals[k-1].end > newInterval.end){\r\n\t\t\t\tnewInterval.end = intervals[k-1].end;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tA.push_back(newInterval);\r\n\r\n\t\t//search the end\r\n\t\tfor(int i=k; i<intervals.size();i++){\r\n\t\t\tA.push_back(intervals[i]);\r\n\t\t}\r\n\r\n\t\treturn A;\r\n    }\r\n};\r\n\r\nvoid main(){\r\n\tSolution s;\r\n\r\n\tsystem(\"pause\");\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":2323}]],"length":2323}
{"contributors":[],"silentsave":false,"ts":1375404279725,"patch":[[{"diffs":[[0,"/*"],[-1,"Insert"],[1,"Merge"],[0," Int"]],"start1":0,"start2":0,"length1":12,"length2":11},{"diffs":[[0,"Interval"],[1,"s"],[0,"Mar 27 '"]],"start1":8,"start2":8,"length1":16,"length2":17},{"diffs":[[0," '12"],[-1,"3940 / 13994\r\nGiven a set of non-overlapping intervals, insert a new interval into the"],[1,"4174 / 14847\r\nGiven a collection of"],[0," int"]],"start1":23,"start2":23,"length1":94,"length2":43},{"diffs":[[0,"vals"],[1,","],[0," "],[-1,"("],[0,"merge "],[-1,"if necessary).\r\n\r\nYou may assume that the intervals were initially sorted according to their start times.\r\n\r\nExample 1:\r\nGiven intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].\r\n\r\nE"],[1,"all overlapping intervals.\r\n\r\nFor e"],[0,"xample"],[-1," 2:"],[1,","],[0,"\r\nGi"]],"start1":68,"start2":68,"length1":221,"length2":58},{"diffs":[[0," [1,"],[-1,"2],[3,5],[6,7"],[1,"3],[2,6"],[0,"],[8"]],"start1":129,"start2":129,"length1":21,"length2":15},{"diffs":[[0,"],[1"],[-1,"2,16], insert and merge [4,9] in as"],[1,"5,18],\r\nreturn"],[0," [1,"],[-1,"2],[3"],[1,"6],[8"],[0,",10],[1"],[-1,"2,16].\r\n\r\nThis is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10"],[1,"5,18"],[0,"].\r\n"]],"start1":147,"start2":147,"length1":139,"length2":42}]],"length":2006,"saved":false}
{"ts":1375404295703,"patch":[[{"diffs":[[0,"\r\n\r\n"],[-1,"class Solution {\r\npublic:\r\n    vector<Interval> insert(vector<Interval> &intervals, Interval new"],[1,"/**\r\n * Definition for an interval.\r\n * struct "],[0,"Interval"],[-1,")"],[0," {\r\n "],[-1,"  "],[1,"*"],[0,"     "],[-1,"// Start typing your C/C++ solution below\r\n   "],[1,"int start;\r\n *"],[0,"     "],[-1,"// DO NOT write int main() function\r\n  "],[1,"int end;\r\n *"],[0,"     "],[-1," vector<Interval> A;\r\n\t\tif(intervals.size() == 0){\r\n\t\t\tA.push_back(newInterval);\r\n\t\t\treturn A;\r\n\t\t}\r\n\r\n\t\tint k = 0;\r\n\t\tfor(int i=0; i<intervals.size();i++){\r\n\t\t\tif(intervals[i].end < newInterval.start){\r\n\t\t\t\tA.push_back(intervals[i]);\r\n\t\t\t\tk++;\r\n\t\t\t}else{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(k<intervals.size() && intervals[k].start < newInterval.start){\r\n\t\t\tnewInterval.start = intervals[k].start;\r\n\t\t}\t\t\r\n\r\n\t\tfor(int i=k; i<intervals.size();i++){\r\n\t\t\tif(intervals[i].start <= newInterval.end){\r\n\t\t\t\tk++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(k>0){\r\n\t\t\tif(intervals[k-1].end > newInterval.end){\r\n\t\t\t\tnewInterval.end = intervals[k-1].end;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tA.push_back(newInterval);\r\n\r\n\t\t//search the end\r\n\t\tfor(int i=k; i<intervals.size();i++){\r\n\t\t\tA.push_back(intervals[i]);\r\n\t\t}\r\n\r\n\t\treturn A;"],[1,"Interval() : start(0), end(0) {}\r\n *     Interval(int s, int e) : start(s), end(e) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    vector<Interval> merge(vector<Interval> &intervals) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        "],[0,"\r\n  "]],"start1":936,"start2":936,"length1":1007,"length2":399}]],"length":1398,"saved":false}
{"ts":1375404298840,"patch":[[{"diffs":[[0,"\r\n\r\n"],[-1,"/**\r\n * Definition for an interval.\r\n * struct Interval {\r\n *     int start;\r\n *     int end;\r\n *     Interval() : start(0), end(0) {}\r\n *     Interval(int s, int e) : start(s), end(e) {}\r\n * };\r\n */\r\n"],[0,"clas"]],"start1":936,"start2":936,"length1":209,"length2":8}]],"length":1197,"saved":false}
{"contributors":[],"silentsave":false,"ts":1375418532219,"patch":[[{"diffs":[[0,"public:\r"],[1,"\n\r\n    struct IntervalCompare{\r\n        \r\n    }\r\n    \r"],[0,"\n    vec"]],"start1":958,"start2":958,"length1":16,"length2":70}]],"length":1251,"saved":false}
{"contributors":[],"silentsave":false,"ts":1375418585017,"patch":[[{"diffs":[[0,"mpare{\r\n        "],[1,"bool operator () (const Interval a, const Interval b){\r\n            return a.start < b.start;\r\n        }"],[0,"\r\n    }\r\n    \r\n "]],"start1":990,"start2":990,"length1":32,"length2":136}]],"length":1355,"saved":false}
{"ts":1375418658829,"patch":[[{"diffs":[[0,"    }\r\n    }"],[1,";"],[0,"\r\n    \r\n    "]],"start1":1105,"start2":1105,"length1":24,"length2":25},{"diffs":[[0,"\r\n        \r\n"],[1,"        //sort Interval by start\r\n        sort(intervals.begin(), intervals.end(), IntervalCompare);\r\n        \r\n        \r\n"],[0,"    }\r\n};\r\n\r"]],"start1":1279,"start2":1279,"length1":24,"length2":146}]],"length":1478,"saved":false}
{"ts":1375418677038,"patch":[[{"diffs":[[0,"  \r\n        "],[1,"for(int i=0;i<intervals.size();i++){\r\n        \r\n        }"],[0,"\r\n    }\r\n};\r"]],"start1":1399,"start2":1399,"length1":24,"length2":81}]],"length":1535,"saved":false}
{"ts":1375420586268,"patch":[[{"diffs":[[0,"tion\r\n        \r\n"],[1,"        vector<Interval> A;\r\n        if(intervals.size() == 0) return A;\r\n        \r\n"],[0,"        //sort I"]],"start1":1275,"start2":1275,"length1":32,"length2":116}]],"length":1619,"saved":false}
{"ts":1375421212818,"patch":[[{"diffs":[[0,"    "],[-1,"for("],[0,"int "],[-1,"i=0;i"],[1,"k=0;\r\n        while(k"],[0,"<int"]],"start1":1491,"start2":1491,"length1":21,"length2":33},{"diffs":[[0,"e();"],[-1,"i++"],[0,"){\r\n"]],"start1":1534,"start2":1534,"length1":11,"length2":8},{"diffs":[[0,"e();){\r\n        "],[1,"    \r\n            k++;"],[0,"\r\n        }\r\n   "]],"start1":1534,"start2":1534,"length1":32,"length2":54}]],"length":1650,"saved":false}
{"ts":1375421216719,"patch":[[{"diffs":[[0,"    "],[-1,"k++;"],[0,"\r\n  "]],"start1":1564,"start2":1564,"length1":12,"length2":8}]],"length":1646,"saved":false}
{"ts":1375421233841,"patch":[[{"diffs":[[0,".size();){\r\n"],[1,"            int begin = intervals[k].begin;\r\n"],[0,"            "]],"start1":1530,"start2":1530,"length1":24,"length2":69}]],"length":1691,"saved":false}
{"ts":1375421245257,"patch":[[{"diffs":[[0,"n;\r\n            "],[1,"int end = interval[k].end;"],[0,"\r\n            \r\n"]],"start1":1583,"start2":1583,"length1":32,"length2":58}]],"length":1717,"saved":false}
{"ts":1375421248304,"patch":[[{"diffs":[[0,"vals[k]."],[-1,"begin"],[1,"start"],[0,";\r\n     "]],"start1":1571,"start2":1571,"length1":21,"length2":21}]],"length":1717,"saved":false}
{"ts":1375421257004,"patch":[[{"diffs":[[0,"    int "],[-1,"begin"],[1,"start"],[0," = inter"]],"start1":1550,"start2":1550,"length1":21,"length2":21},{"diffs":[[0,"\r\n            \r\n"],[1,"            \r\n"],[0,"        }\r\n    }"]],"start1":1625,"start2":1625,"length1":32,"length2":46}]],"length":1731,"saved":false}
{"ts":1375421276089,"patch":[[{"diffs":[[0,"s.size()"],[-1,";"],[0,"){\r\n    "]],"start1":1529,"start2":1529,"length1":17,"length2":16},{"diffs":[[0,"  \r\n            "],[1,"while(end)"],[0,"\r\n        }\r\n   "]],"start1":1636,"start2":1636,"length1":32,"length2":42}]],"length":1740,"saved":false}
{"ts":1375421286420,"patch":[[{"diffs":[[0,"ile("],[-1,"end)"],[1,"k+1 < intervals.size()){\r\n                \r\n            }"],[0,"\r\n  "]],"start1":1654,"start2":1654,"length1":12,"length2":65}]],"length":1793,"saved":false}
{"ts":1375421294161,"patch":[[{"diffs":[[0,"intervals.size()"],[1," && "],[0,"){\r\n            "]],"start1":1664,"start2":1664,"length1":32,"length2":36}]],"length":1797,"saved":false}
{"ts":1375421336970,"patch":[[{"diffs":[[0,"         }\r\n"],[1,"            A.push_back(Interval(start, end));\r\n"],[0,"        }\r\n "]],"start1":1709,"start2":1709,"length1":24,"length2":72}]],"length":1845,"saved":false}
{"contributors":[],"silentsave":false,"ts":1375422620323,"patch":[[{"diffs":[[0,"ze() && "],[1,"end >= intervals[k+1].start"],[0,"){\r\n    "]],"start1":1676,"start2":1676,"length1":16,"length2":43}]],"length":1872,"saved":false}
{"ts":1375422627674,"patch":[[{"diffs":[[0,"                "],[1,"k++;"],[0,"\r\n            }\r"]],"start1":1715,"start2":1715,"length1":32,"length2":36}]],"length":1876,"saved":false}
{"ts":1375422630458,"patch":[[{"diffs":[[0,"1].start){\r\n"],[1,"                \r\n"],[0,"            "]],"start1":1703,"start2":1703,"length1":24,"length2":42}]],"length":1894,"saved":false}
{"ts":1375422635720,"patch":[[{"diffs":[[0,"                "],[1,"end = max()"],[0,"\r\n              "]],"start1":1715,"start2":1715,"length1":32,"length2":43}]],"length":1905,"saved":false}
{"ts":1375422650422,"patch":[[{"diffs":[[0,"d = max("],[-1,")"],[1,"end, intervals[k+1].end);"],[0,"\r\n      "]],"start1":1733,"start2":1733,"length1":17,"length2":41}]],"length":1929,"saved":false}
{"ts":1375422700887,"patch":[[{"diffs":[[0,"\n        }\r\n"],[1,"        return A;\r\n"],[0,"    }\r\n};\r\n\r"]],"start1":1852,"start2":1852,"length1":24,"length2":43}]],"length":1948,"saved":false}
{"ts":1375422818870,"patch":[[{"diffs":[[0,"}\r\n    }"],[1,"intervalCompare"],[0,";\r\n    \r"]],"start1":1109,"start2":1109,"length1":16,"length2":31},{"diffs":[[0,".end(), "],[-1,"I"],[1,"i"],[0,"ntervalC"]],"start1":1465,"start2":1465,"length1":17,"length2":17},{"diffs":[[0,"interval"],[1,"s"],[0,"[k].end;"]],"start1":1623,"start2":1623,"length1":16,"length2":17}]],"length":1964,"saved":false}
{"ts":1375422866451,"patch":[[{"diffs":[[0,"rt, end));\r\n"],[1,"            k++;\r\n"],[0,"        }\r\n "]],"start1":1857,"start2":1857,"length1":24,"length2":42}]],"length":1982,"saved":false}
