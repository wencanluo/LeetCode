{"ts":1374622504159,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*Recover Binary Search Tree\r\n\r\nTwo elements of a binary search tree (BST) are swapped by mistake.\r\n\r\nRecover the tree without changing its structure.\r\n\r\nNote:\r\nA solution using O(n) space is pretty straight forward. Could you devise a constant space solution?\r\nconfused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\r\n\r\nYour algorithm should run in O(n) complexity.\r\nAuthor: Wencan Luo\r\nLanguage: C++\r\nDate: 06/20/2013\r\n*/\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n#include<vector>\r\n#include<string>\r\n#include<algorithm>\r\n\r\n#include<map>\r\n//#include<unordered_set>\r\n\r\n#include<queue>\r\n#include<set>\r\n\r\nstruct TreeNode {\r\n\tint val;\r\n\tTreeNode *left;\r\n\tTreeNode *right;\r\n\tTreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n\tvoid InOrderTravel(TreeNode *root, vector<pair<int, TreeNode *> > &vec){\r\n\t\tif(root == NULL) return;\r\n\t\t\r\n\t\tif(root->left != NULL) InOrderTravel(root->left, vec);\r\n\t\tvec.push_back(make_pair(root->val, root));\r\n\t\tif(root->right != NULL) InOrderTravel(root->right, vec);\r\n\r\n\t}\r\n\r\n\tvoid FindLeft(TreeNode *root, TreeNode **lastone, TreeNode **left){\r\n\t\tif(root == NULL) return;\r\n\t\t\r\n\t\tif(root->left != NULL) FindLeft(root->left, lastone, left);\r\n\t\t\r\n\t\tif(*lastone != NULL){\r\n\t\t\tif(root->val < (*lastone)->val){\r\n\t\t\t\t*left = *lastone;\r\n\t\t\t\treturn;\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\t*lastone = root;\r\n\r\n\t\tif(root->right != NULL) FindLeft(root->right, lastone, left);\r\n\t}\r\n\r\n\tvoid FindRight(TreeNode *root, TreeNode **lastone, TreeNode **right){\r\n\t\tif(root == NULL) return;\r\n\t\t\r\n\t\tif(root->right != NULL) FindRight(root->right, lastone, right);\r\n\t\t\r\n\t\tif(*lastone != NULL){\r\n\t\t\tif(root->val > (*lastone)->val){\r\n\t\t\t\t*right = *lastone;\r\n\t\t\t\treturn;\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\t*lastone = root;\r\n\t\t\r\n\t\tif(root->left != NULL) FindRight(root->left, lastone, right);\r\n\t}\r\n\r\n\tvoid recoverTree(TreeNode *root) {\r\n\t\tTreeNode *left = NULL;\r\n\t\tTreeNode *right = NULL;\r\n\t\tTreeNode *lastone = NULL;\r\n\t\tFindLeft(root, &lastone, &left);\r\n\t\tlastone = NULL;\r\n\t\tFindRight(root, &lastone, &right);\r\n\r\n\t\tif(left == NULL || right == NULL) return;\r\n\r\n\t\tint tmp;\r\n\t\ttmp = left->val;\r\n\t\tleft->val = right->val;\r\n\t\tright->val = tmp;\r\n\t}\r\n\r\n    void recoverTree2(TreeNode *root) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        vector< pair<int, TreeNode *> > vec;\r\n\r\n\t\tInOrderTravel(root, vec);\r\n\t\t\r\n\t\tif(vec.size() < 2) return;\r\n\r\n\t\tint left = -1;\r\n\t\tint right = -1;\r\n\r\n\t\tfor(int i=0;i<vec.size()-1;i++){\r\n\t\t\tif (vec[i].first > vec[i+1].first) {\r\n\t\t\t\tleft = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor(int i=vec.size()-1;i>0;i--){\r\n\t\t\tif (vec[i].first < vec[i-1].first) {\r\n\t\t\t\tright = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t//swap\r\n\t\tif(left == -1 || right == -1) return;\r\n\r\n\t\tint tmp;\r\n\t\ttmp = vec[left].first;\r\n\t\tvec[left].second->val = vec[right].first;\r\n\t\tvec[right].second->val = tmp;\r\n    }\r\n};\r\n\r\nvoid main(){\r\n\tTreeNode root(2);\r\n\tTreeNode left(3);\r\n\tTreeNode right(4);\r\n\tTreeNode node(1);\r\n\r\n\troot.left = &left;\r\n\troot.right = &right;\r\n\tright.left = &node;\r\n\r\n\tSolution s;\r\n\r\n\ts.recoverTree(&root);\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":3089}]],"length":3089}
