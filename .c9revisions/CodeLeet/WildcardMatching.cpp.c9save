{"ts":1375846384964,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*Wildcard MatchingMar 16 '126416 / 25360\r\nImplement wildcard pattern matching with support for '?' and '*'.\r\n\r\n'?' Matches any single character.\r\n'*' Matches any sequence of characters (including the empty sequence).\r\n\r\nThe matching should cover the entire input string (not partial).\r\n\r\nThe function prototype should be:\r\nbool isMatch(const char *s, const char *p)\r\n\r\nSome examples:\r\nisMatch(\"aa\",\"a\") ? false\r\nisMatch(\"aa\",\"aa\") ? true\r\nisMatch(\"aaa\",\"aa\") ? false\r\nisMatch(\"aa\", \"*\") ? true\r\nisMatch(\"aa\", \"a*\") ? true\r\nisMatch(\"ab\", \"?*\") ? true\r\nisMatch(\"aab\", \"c*a*b\") ? false\r\n\r\nAuthor: Wencan Luo\r\nLanguage: C++\r\nDate: 08/04/2013\r\n*/\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n#include<climits>\r\n\r\n#include<vector>\r\n#include<string>\r\n#include<algorithm>\r\n\r\n#include<map>\r\n//#include<unordered_set>\r\n\r\n#include<queue>\r\n#include<set>\r\n\r\n// Definition for binary tree\r\n struct TreeNode {\r\n     int val;\r\n     TreeNode *left;\r\n     TreeNode *right;\r\n TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n};\r\n\r\n//Definition for singly-linked list.\r\nstruct ListNode {\r\n    int val;\r\n    ListNode *next;\r\n    ListNode(int x) : val(x), next(NULL) {}\r\n};\r\n\r\n// Definition for an interval.\r\nstruct Interval {\r\n    int start;\r\n    int end;\r\n    Interval() : start(0), end(0) {}\r\n    Interval(int s, int e) : start(s), end(e) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    bool isMatchRec(const char *s, int m, const char *p, int n){\r\n        if(m==0 && n==0) return true;\r\n        if(m==0){\r\n            for(int i=0;i<n;i++){\r\n                if(p[i] != '*') return false;\r\n            }\r\n            return true;  \r\n        }\r\n        if(n==0){\r\n            for(int i=0;i<m;i++){\r\n                if(s[i] != '*') return false;\r\n            }\r\n            return true;\r\n        } \r\n        \r\n        if(s[m-1] == '*'){\r\n            if(p[n-1] == '*'){\r\n                return isMatchRec(s, m-1, p, n-1) || isMatchRec(s, m, p, n-1) || isMatchRec(s, m-1, p, n);\r\n            }else if(p[n-1] == '?'){\r\n                return isMatchRec(s, m-1, p, n-1) || isMatchRec(s, m, p, n-1);\r\n            }else{\r\n                return isMatchRec(s, m-1, p, n-1) || isMatchRec(s, m, p, n-1);\r\n            }\r\n        }else if(s[m-1] == '?'){\r\n            if(p[n-1] == '*'){\r\n                return isMatchRec(s, m-1, p, n-1) || isMatchRec(s, m, p, n-1) || isMatchRec(s, m-1, p, n);\r\n            }else if(p[n-1] == '?'){\r\n                return isMatchRec(s, m-1, p, n-1);\r\n            }else{    \t\t\t\r\n                return isMatchRec(s, m-1, p, n-1);\r\n            }\r\n        }else{//letter\r\n            if(p[n-1] == '*'){\r\n                 return isMatchRec(s, m-1, p, n-1) || isMatchRec(s, m, p, n-1) || isMatchRec(s, m-1, p, n);\r\n            }else if(p[n-1] == '?'){\r\n                return isMatchRec(s, m-1, p, n-1);\r\n            }else{\r\n\t\t\t\tif(s[m-1] == p[n-1]) return isMatchRec(s, m-1, p, n-1);\r\n\t\t\t\treturn false;\r\n            }\r\n        }\r\n    }\r\n    \r\n\tbool isMatch(const char *s, const char *p) {//O(m+n)\r\n        int m = strlen(s);\r\n        int n = strlen(p);\r\n        \r\n        bool sHasStar = false;\r\n        int sCount = 0;\r\n        for(int i=0;i<m;i++){\r\n            if(s[i] == '*') {\r\n                sHasStar = true;\r\n            }else{\r\n                sCount++;\r\n            }\r\n        }\r\n        \r\n        bool pHasStar = false;\r\n        int pCount = 0;\r\n        for(int i=0;i<n;i++){\r\n            if(p[i] == '*') {\r\n                pHasStar = true;\r\n            }else{\r\n                pCount++;\r\n            }\r\n        }\r\n        \r\n        if(sHasStar && !pHasStar){\r\n            if(sCount > pCount) return false;\r\n        }\r\n        \r\n        if(!sHasStar && pHasStar){\r\n            if(sCount < pCount) return false;\r\n        }\r\n        \r\n        vector<bool>  A;\r\n\t\tvector<bool>  B;\r\n\t\tvector<bool>  C;\r\n\t\tA.resize(n+1, false);\r\n\t\tB.resize(n+1, false);\r\n\t\tC.resize(m+1, false);\r\n\r\n\t\tA[0] = true;\r\n\t\tfor(int j=0;j<n;j++){\r\n\t\t\tif(p[j] != '*') break;\r\n\t\t\tA[j+1] = true;\r\n        }\r\n\r\n        for(int i=0;i<m;i++){\r\n            if(s[i] != '*') break;\r\n\t\t\tC[i+1] = true;\r\n        }\r\n   \r\n\t\tfor(int i=0;i<m;i++){\r\n\t\t\tB[0] = C[i];\r\n\r\n\t\t\tfor(int j=0;j<n;j++){\r\n\t\t\t\tB[j+1] = false;\r\n\t\t\t\t\r\n\t\t\t\tif(p[j] == '*'){\r\n\t\t\t\t\tB[j+1] = A[j] || B[j] || A[j+1];\r\n\t\t\t\t}else if(p[j] == '?' || s[i] == p[j]){\r\n\t\t\t\t\tB[j+1] = A[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tA = B;\r\n\t\t}\r\n        \r\n        return A[n];\r\n\t}\r\n\r\n    bool isMatch_Omn(const char *s, const char *p) {//O(m*n) Time, O(n) Space\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        int m = strlen(s);\r\n        int n = strlen(p);\r\n        \r\n\t\tvector<bool>  A;\r\n\t\tvector<bool>  B;\r\n\t\tvector<bool>  C;\r\n\t\tA.resize(n+1, false);\r\n\t\tB.resize(n+1, false);\r\n\t\tC.resize(m+1, false);\r\n\r\n\t\tA[0] = true;\r\n\t\tfor(int j=0;j<n;j++){\r\n\t\t\tif(p[j] != '*') break;\r\n\t\t\tA[j+1] = true;\r\n        }\r\n\r\n        for(int i=0;i<m;i++){\r\n            if(s[i] != '*') break;\r\n\t\t\tC[i+1] = true;\r\n        }\r\n   \r\n\t\tfor(int i=0;i<m;i++){\r\n\t\t\tB[0] = C[i];\r\n\r\n\t\t\tfor(int j=0;j<n;j++){\r\n\t\t\t\tB[j+1] = false;\r\n\t\t\t\tif(s[i] == '*'){\r\n\t\t\t\t\tif(p[j] == '*'){\r\n\t\t\t\t\t\tB[j+1] = A[j] || B[j] || A[j+1];\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tB[j+1] = A[j] || B[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(p[j] == '*'){\r\n\t\t\t\t\t\tB[j+1] = A[j] || B[j] || A[j+1];\r\n\t\t\t\t\t}else if(s[i] == '?' || p[j] == '?' || s[i] == p[j]){\r\n\t\t\t\t\t\tB[j+1] = A[j];\r\n\t\t\t\t\t}\r\n                    \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tA = B;\r\n\t\t}\r\n        \r\n        return A[n];\r\n    }\r\n\r\n\tbool isMatch_O2Space(const char *s, const char *p) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        int m = strlen(s);\r\n        int n = strlen(p);\r\n        \r\n\t\tvector< vector<bool> > A;\r\n\t\tA.resize(m+1);\r\n\r\n\t\tfor(int i=0;i<A.size();i++){\r\n\t\t\tA[i].resize(n+1,false);\r\n\t\t}\r\n\r\n\t\tA[0][0] = true;\r\n\t\tfor(int i=0;i<m;i++){\r\n\t\t\tif(s[i] != '*') break;\r\n\t\t\tA[i+1][0] = true;\r\n        }\r\n\r\n        for(int j=0;j<n;j++){\r\n            if(p[j] != '*') break;\r\n\t\t\tA[0][j+1] = true;\r\n        }\r\n   \r\n\t\tfor(int i=0;i<m;i++){\r\n\t\t\tfor(int j=0;j<n;j++){\r\n\t\t\t\tif(s[i] == '*'){\r\n\t\t\t\t\tif(p[j] == '*'){\r\n\t\t\t\t\t\tA[i+1][j+1] = A[i][j] || A[i+1][j] || A[i][j+1];\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tA[i+1][j+1] = A[i][j] || A[i+1][j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(p[j] == '*'){\r\n\t\t\t\t\t\tA[i+1][j+1] = A[i][j] || A[i+1][j] || A[i][j+1];\r\n\t\t\t\t\t}else if(s[i] == '?' || p[j] == '?' || s[i] == p[j]){\r\n\t\t\t\t\t\tA[i+1][j+1] = A[i][j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n        \r\n        return A[m][n];\r\n    }\r\n};\r\n\r\nvoid main(){\r\n\tSolution s;\r\n\r\n\tcout << s.isMatch(\"\",\"*\") << endl;\r\n\tcout << s.isMatch(\"a\",\"b\") << endl;\r\n\tcout << s.isMatch(\"a*\",\"*a\") << endl;\r\n\tcout << s.isMatch(\"***\",\"*\") << endl;\r\n    \r\n\tsystem(\"pause\");\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":6668}]],"length":6668}
