{"ts":1375660138410,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*Wildcard MatchingMar 16 '126416 / 25360\r\nImplement wildcard pattern matching with support for '?' and '*'.\r\n\r\n'?' Matches any single character.\r\n'*' Matches any sequence of characters (including the empty sequence).\r\n\r\nThe matching should cover the entire input string (not partial).\r\n\r\nThe function prototype should be:\r\nbool isMatch(const char *s, const char *p)\r\n\r\nSome examples:\r\nisMatch(\"aa\",\"a\") ? false\r\nisMatch(\"aa\",\"aa\") ? true\r\nisMatch(\"aaa\",\"aa\") ? false\r\nisMatch(\"aa\", \"*\") ? true\r\nisMatch(\"aa\", \"a*\") ? true\r\nisMatch(\"ab\", \"?*\") ? true\r\nisMatch(\"aab\", \"c*a*b\") ? false\r\n\r\nAuthor: Wencan Luo\r\nLanguage: C++\r\nDate: 08/04/2013\r\n*/\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n#include<climits>\r\n\r\n#include<vector>\r\n#include<string>\r\n#include<algorithm>\r\n\r\n#include<map>\r\n//#include<unordered_set>\r\n\r\n#include<queue>\r\n#include<set>\r\n\r\n// Definition for binary tree\r\n struct TreeNode {\r\n     int val;\r\n     TreeNode *left;\r\n     TreeNode *right;\r\n TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n};\r\n\r\n//Definition for singly-linked list.\r\nstruct ListNode {\r\n    int val;\r\n    ListNode *next;\r\n    ListNode(int x) : val(x), next(NULL) {}\r\n};\r\n\r\n// Definition for an interval.\r\nstruct Interval {\r\n    int start;\r\n    int end;\r\n    Interval() : start(0), end(0) {}\r\n    Interval(int s, int e) : start(s), end(e) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    bool canJump(int A[], int n) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        if(n==0) return true;\r\n        \r\n        int maxK = 0;\r\n        for(int i=0;i<n && i <= maxK;i++){\r\n            if(maxK < A[i] + i){\r\n                maxK = A[i] + i;\r\n            }\r\n        }\r\n        \r\n        if(maxK >= n-1) return true;       \r\n        return false;\r\n    }\r\n    \r\n    int jump(int A[], int n) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        if(n==0) return 0;\r\n        \r\n        vector<int> S;\r\n        S.resize(n, 0);\r\n        \r\n        int maxK = 0;\r\n        for(int i=0;i<n && i <= maxK;i++){\r\n            if(maxK < A[i] + i){\r\n                for(int j=maxK+1; j < n && j <= A[i] + i; j++){\r\n                    S[j] = S[i] + 1;\r\n                }\r\n                maxK = A[i] + i;\r\n            }\r\n        }\r\n        \r\n        return S[n-1];\r\n    }\r\n};\r\n\r\nvoid main(){\r\n\tSolution s;\r\n\r\n    int A[] = {2,3,1,1,4};\r\n    cout << s.jump(A, sizeof(A)/sizeof(A[0]));\r\n    \r\n\tsystem(\"pause\");\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":2477}]],"length":2477}
{"contributors":[],"silentsave":false,"ts":1375726949285,"patch":[[{"diffs":[[0,"    "],[-1,"bool canJump(int A[], int n"],[1,"\r\n    bool isMatch(const char *s, const char *p"],[0,") {\r"]],"start1":1363,"start2":1363,"length1":35,"length2":55},{"diffs":[[0,"   i"],[-1,"f(n==0) return true;\r\n        \r\n        int maxK = 0;\r\n        for(int i=0;i<n && i <= maxK;i++){\r\n            if(maxK < A[i] + i){\r\n                maxK = A[i] + i;\r\n            }\r\n        }\r\n        \r\n        if(maxK >= n-1"],[1,"nt m = strlen(s);\r\n        int n = strlen(p);\r\n        if(m==0 && n==0"],[0,") re"]],"start1":1520,"start2":1520,"length1":233,"length2":78},{"diffs":[[0,"rn true;"],[-1,"       "],[0,"\r\n      "]],"start1":1600,"start2":1600,"length1":23,"length2":16},{"diffs":[[0,"n true;\r\n       "],[1," if(m==0)"],[0," return false;\r\n"]],"start1":1601,"start2":1601,"length1":32,"length2":41},{"diffs":[[0,"e;\r\n"],[-1,"    }\r\n    \r\n    int jump(int A[], int n) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n"],[0,"    "]],"start1":1638,"start2":1638,"length1":149,"length2":8},{"diffs":[[0," return "],[-1,"0"],[1,"false"],[0,";\r\n     "]],"start1":1658,"start2":1658,"length1":17,"length2":21},{"diffs":[[0,"    "],[-1,"vector<int> S;\r\n        S.resize(n, 0);\r\n        \r\n        int maxK = 0;\r\n        for(int i=0;i<n && i <= maxK;i++){\r\n            if(maxK < A[i] + i){\r\n                for(int j=maxK+1; j < n && j <= A[i] + i; j++){\r\n                    S[j] = S[i] + 1;\r\n                }\r\n                maxK = A[i] + i;\r\n            }\r\n        }\r\n        \r\n        return S[n-1]"],[1,"\r\n        return isMatchRec(s, m, p, n)"],[0,";\r\n "]],"start1":1688,"start2":1688,"length1":373,"length2":47}]],"length":1881,"saved":false}
{"ts":1375727335215,"patch":[[{"diffs":[[0,"ublic:\r\n"],[1,"    bool isMatchRec(const char *s, int m, const char *p, int n){\r\n        if(m==0 && n==0) return true;\r\n        if(m==0){\r\n            for(int i=0;i<n;i++){\r\n                if(p[i] != '*') return false;\r\n            }\r\n            return true;  \r\n        } \r\n        if(n==0){\r\n            for(int i=0;i<m;i++){\r\n                if(s[i] != '*') return false;\r\n            }\r\n            return true;  \r\n        } \r\n        \r\n        \r\n        \r\n    }\r\n"],[0,"    \r\n"],[-1,""],[0,"    bool"]],"start1":1355,"start2":1355,"length1":22,"length2":476},{"diffs":[[0,"strlen(s);\r\n"],[1,""],[0,"        int "]],"start1":1985,"start2":1985,"length1":24,"length2":24},{"diffs":[[0,");\r\n"],[-1,"        if(m==0 && n==0) return true;\r\n        if(m==0) return false;\r\n        if(n==0) return false;\r\n        \r\n"],[0,"    "]],"start1":2021,"start2":2021,"length1":121,"length2":8}]],"length":2222,"saved":false}
{"ts":1375727506904,"patch":[[{"diffs":[[0,"  } \r\n        \r\n"],[1,"        if(s[m-1] == '*'){\r\n            \r\n        }else if(s[m-1] == '?'){\r\n            \r\n        }else{\r\n            \r\n        }\r\n"],[0,"        \r\n      "]],"start1":1774,"start2":1774,"length1":32,"length2":163}]],"length":2353,"saved":false}
{"ts":1375727756443,"patch":[[{"diffs":[[0,"  }else{"],[1,"//letter"],[0,"\r\n      "]],"start1":1886,"start2":1886,"length1":16,"length2":24},{"diffs":[[0,"er\r\n            "],[1,"if(p[n-1] == '*'){\r\n            \r\n            }else if(p[n-1] == '?'){\r\n                \r\n            }else{\r\n                \r\n            }"],[0,"\r\n        }\r\n   "]],"start1":1900,"start2":1900,"length1":32,"length2":173}]],"length":2502,"saved":false}
{"ts":1375727760761,"patch":[[{"diffs":[[0,"    "],[-1,"\r\n        }else if(s[m-1] == '?'){\r\n            "],[1,"if(p[n-1] == '*'){\r\n            \r\n            }else if(p[n-1] == '?'){\r\n                \r\n            }else{\r\n                \r\n            }\r\n        }else if(s[m-1] == '?'){\r\n            if(p[n-1] == '*'){\r\n            \r\n            }else if(p[n-1] == '?'){\r\n                \r\n            }else{\r\n                \r\n            }"],[0,"\r\n  "]],"start1":1826,"start2":1826,"length1":56,"length2":338}]],"length":2784,"saved":false}
{"ts":1375727765994,"patch":[[{"diffs":[[0," }\r\n"],[-1,"        \r\n        \r\n"],[0,"    "]],"start1":2348,"start2":2348,"length1":28,"length2":8}]],"length":2764,"saved":false}
{"ts":1375727812901,"patch":[[{"diffs":[[0,"                "],[1,"return isMatchRec(s, m-1, p, n-1);"],[0,"\r\n            }\r"]],"start1":2308,"start2":2308,"length1":32,"length2":66}]],"length":2798,"saved":false}
{"ts":1375727849270,"patch":[[{"diffs":[[0,"){\r\n            "],[1,"     return isMatchRec(s, m-1, p, n-1) || isMatchRec(s, m-1, p, n-1);"],[0,"\r\n            }e"]],"start1":2214,"start2":2214,"length1":32,"length2":101}]],"length":2867,"saved":false}
{"ts":1375727873874,"patch":[[{"diffs":[[0,"Rec(s, m-1, p, n"],[-1,"-1"],[0,");\r\n            "]],"start1":2279,"start2":2279,"length1":34,"length2":32}]],"length":2865,"saved":false}
{"ts":1375728477590,"patch":[[{"diffs":[[0,"                "],[1,"return isMatchRec(s, m-1, p, n-1);"],[0,"\r\n            }e"]],"start1":2337,"start2":2337,"length1":32,"length2":66}]],"length":2899,"saved":false}
{"ts":1375728817932,"patch":[[{"diffs":[[0,"                "],[1,"return isMatchRec(s, m-1, p, n-1);"],[0,"\r\n            }e"]],"start1":2091,"start2":2091,"length1":32,"length2":66},{"diffs":[[0,"                "],[1,"return isMatchRec(s, m-1, p, n-1);"],[0,"\r\n            }\r"]],"start1":2163,"start2":2163,"length1":32,"length2":66}]],"length":2967,"saved":false}
{"ts":1375728820258,"patch":[[{"diffs":[[0,"){\r\n            "],[1,"    "],[0,"\r\n            }e"]],"start1":2035,"start2":2035,"length1":32,"length2":36}]],"length":2971,"saved":false}
{"ts":1375728825645,"patch":[[{"diffs":[[0,"                "],[1,"return isMatchRec(s, m-1, p, n-1) || isMatchRec(s, m-1, p, n);"],[0,"\r\n            }e"]],"start1":2039,"start2":2039,"length1":32,"length2":94}]],"length":3033,"saved":false}
{"ts":1375728830973,"patch":[[{"diffs":[[0,"){\r\n            "],[1,"    "],[0,"\r\n            }e"]],"start1":1846,"start2":1846,"length1":32,"length2":36}]],"length":3037,"saved":false}
{"ts":1375728838143,"patch":[[{"diffs":[[0,"                "],[1,"return isMatchRec(s, m-1, p, n-1) || isMatchRec(s, m-1, p, n);"],[0,"\r\n            }\r"]],"start1":1944,"start2":1944,"length1":32,"length2":94}]],"length":3099,"saved":false}
{"ts":1375728855673,"patch":[[{"diffs":[[0,"atchRec(s, m"],[-1,"-1"],[0,", p, n"],[1,"-1"],[0,");\r\n        "]],"start1":2000,"start2":2000,"length1":32,"length2":32}]],"length":3099,"saved":false}
{"ts":1375736175541,"patch":[[{"diffs":[[0,"                "],[1,"return isMatchRec(s, m-1, p, n-1) || isMatchRec(s, m, p, n-1);"],[0,"\r\n            }e"]],"start1":1906,"start2":1906,"length1":32,"length2":94}]],"length":3161,"saved":false}
{"ts":1375736182704,"patch":[[{"diffs":[[0,"                "],[1,"return isMatchRec(s, m-1, p, n-1) || isMatchRec(s, m, p, n-1);"],[0,"\r\n            }e"]],"start1":1850,"start2":1850,"length1":32,"length2":94}]],"length":3223,"saved":false}
{"ts":1375736186511,"patch":[[{"diffs":[[0,"ec(s, m, p, n-1)"],[1," || "],[0,";\r\n            }"]],"start1":1911,"start2":1911,"length1":32,"length2":36}]],"length":3227,"saved":false}
{"ts":1375736192605,"patch":[[{"diffs":[[0,"n-1) || "],[1,"isMatchRec(s, m-1, p, n-1)"],[0,";\r\n     "]],"start1":1923,"start2":1923,"length1":16,"length2":42}]],"length":3253,"saved":false}
{"ts":1375736201341,"patch":[[{"diffs":[[0,"Rec(s, m-1, p, n"],[-1,"-1"],[0,");\r\n            "]],"start1":1938,"start2":1938,"length1":34,"length2":32}]],"length":3251,"saved":false}
{"ts":1375736634393,"patch":[[{"diffs":[[0,"ue;  \r\n        }"],[-1," "],[0,"\r\n        if(n=="]],"start1":1605,"start2":1605,"length1":33,"length2":32}]],"length":3250,"saved":false}
{"ts":1375736658550,"patch":[[{"diffs":[[0,"    return true;"],[-1,"  "],[0,"\r\n        } \r\n  "]],"start1":1747,"start2":1747,"length1":34,"length2":32}]],"length":3248,"saved":false}
{"ts":1375740748170,"patch":[[{"diffs":[[0," isMatchRec(s, m"],[-1,""],[0,""],[1,", p, n-1) || isMatchRec(s, m"],[0,"-1, p, n);\r\n    "]],"start1":2306,"start2":2306,"length1":32,"length2":60},{"diffs":[[0,"          }else{"],[-1,""],[0,""],[1,"    \t\t\t"],[0,"\r\n              "]],"start1":2454,"start2":2454,"length1":32,"length2":39},{"diffs":[[0," isMatchRec(s, m"],[-1,""],[0,""],[1,", p, n-1) || isMatchRec(s, m"],[0,"-1, p, n);\r\n    "]],"start1":2655,"start2":2655,"length1":32,"length2":60},{"diffs":[[0,"    }else{\r\n"],[-1,"               "],[1,"\t\t\t\tif(s[m-1] == p[n-1])"],[0," return isMa"]],"start1":2809,"start2":2809,"length1":39,"length2":48},{"diffs":[[0," m-1, p, n-1);\r\n"],[1,"\t\t\t\treturn false;\r\n"],[0,"            }\r\n "]],"start1":2866,"start2":2866,"length1":32,"length2":51},{"diffs":[[0,"   }\r\n    \r\n"],[1,"\tbool isMatch(const char *s, const char *p) {//O(m+n)\r\n\t}\r\n\r\n"],[0,"    bool isM"]],"start1":2928,"start2":2928,"length1":24,"length2":85},{"diffs":[[0,"    bool isMatch"],[1,"_Omn"],[0,"(const char *s, "]],"start1":3001,"start2":3001,"length1":32,"length2":36},{"diffs":[[0,"ar *p) {"],[1,"//O(m*n) Time, O(n) Space"],[0,"\r\n      "]],"start1":3045,"start2":3045,"length1":16,"length2":41},{"diffs":[[0,"  \r\n"],[-1,"        return isMatchRec(s, m, p, n);\r\n    }\r\n};\r\n\r\nvoid main(){\r\n\tSolution s;\r\n\r\n    int A[] = {2,3,1,1,4};\r\n    cout << s.jump(A, sizeof(A)/sizeof(A[0]))"],[1,"\t\tvector<bool>  A;\r\n\t\tvector<bool>  B;\r\n\t\tvector<bool>  C;\r\n\t\tA.resize(n+1, false);\r\n\t\tB.resize(n+1, false);\r\n\t\tC.resize(m+1, false);\r\n\r\n\t\tA[0] = true;\r\n\t\tfor(int j=0;j<n;j++){\r\n\t\t\tif(p[j] != '*') break;\r\n\t\t\tA[j+1] = true;\r\n        }\r\n\r\n        for(int i=0;i<m;i++){\r\n            if(s[i] != '*') break;\r\n\t\t\tC[i+1] = true;\r\n        }\r\n   \r\n\t\tfor(int i=0;i<m;i++){\r\n\t\t\tB[0] = C[i];\r\n\r\n\t\t\tfor(int j=0;j<n;j++){\r\n\t\t\t\tB[j+1] = false;\r\n\t\t\t\tif(s[i] == '*'){\r\n\t\t\t\t\tif(p[j] == '*'){\r\n\t\t\t\t\t\tB[j+1] = A[j] || B[j] || A[j+1];\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tB[j+1] = A[j] || B[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(p[j] == '*'){\r\n\t\t\t\t\t\tB[j+1] = A[j] || B[j] || A[j+1];\r\n\t\t\t\t\t}else if(s[i] == '?' || p[j] == '?' || s[i] == p[j]){\r\n\t\t\t\t\t\tB[j+1] = A[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tA = B;\r\n\t\t}\r\n        \r\n        return A[n];\r\n    }\r\n\r\n\tbool isMatch_O2Space(const char *s, const char *p) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        int m = strlen(s);\r\n        int n = strlen(p);\r\n        \r\n\t\tvector< vector<bool> > A;\r\n\t\tA.resize(m+1);\r\n\r\n\t\tfor(int i=0;i<A.size();i++){\r\n\t\t\tA[i].resize(n+1,false);\r\n\t\t}\r\n\r\n\t\tA[0][0] = true;\r\n\t\tfor(int i=0;i<m;i++){\r\n\t\t\tif(s[i] != '*') break;\r\n\t\t\tA[i+1][0] = true;\r\n        }\r\n\r\n        for(int j=0;j<n;j++){\r\n            if(p[j] != '*') break;\r\n\t\t\tA[0][j+1] = true;\r\n        }\r\n   \r\n\t\tfor(int i=0;i<m;i++){\r\n\t\t\tfor(int j=0;j<n;j++){\r\n\t\t\t\tif(s[i] == '*'){\r\n\t\t\t\t\tif(p[j] == '*'){\r\n\t\t\t\t\t\tA[i+1][j+1] = A[i][j] || A[i+1][j] || A[i][j+1];\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tA[i+1][j+1] = A[i][j] || A[i+1][j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(p[j] == '*'){\r\n\t\t\t\t\t\tA[i+1][j+1] = A[i][j] || A[i+1][j] || A[i][j+1];\r\n\t\t\t\t\t}else if(s[i] == '?' || p[j] == '?' || s[i] == p[j]){\r\n\t\t\t\t\t\tA[i+1][j+1] = A[i][j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n        \r\n        return A[m][n];\r\n    }\r\n};\r\n\r\nvoid main(){\r\n\tSolution s;\r\n\r\n\tcout << s.isMatch(\"\",\"*\") << endl;\r\n\tcout << s.isMatch(\"a\",\"b\") << endl;\r\n\tcout << s.isMatch(\"a*\",\"*a\") << endl;\r\n\tcout << s.isMatch(\"***\",\"*\") << endl"],[0,";\r\n "]],"start1":3238,"start2":3238,"length1":164,"length2":2006}]],"length":5271,"saved":false}
{"contributors":[],"silentsave":false,"ts":1375769358861,"patch":[[{"diffs":[[0,"\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n"],[1,"                if(!B[j+1]) break;\r\n"],[0,"\t\t\t}\r\n\t\t\tA = B;\r"]],"start1":3964,"start2":3964,"length1":32,"length2":68}]],"length":5307,"saved":false}
{"ts":1375771124892,"patch":[[{"diffs":[[0,"\t\t\t\t\t}\r\n"],[-1,"\t\t\t\t}\r\n"],[0,"        "]],"start1":3965,"start2":3965,"length1":23,"length2":16},{"diffs":[[0,"    "],[-1,"if(!B[j+1]) break;"],[1,"    \r\n\t\t\t\t}"],[0,"\r\n\t\t"]],"start1":3985,"start2":3985,"length1":26,"length2":19}]],"length":5293,"saved":false}
{"ts":1375772875786,"patch":[[{"diffs":[[0,"O(m+n)\r\n"],[1,"        int m = strlen(s);\r\n        int n = strlen(p);\r\n        \r\n        bool sHasStar = false;\r\n        int sCount = 0;\r\n        for(int i=0;i<m;i++){\r\n            if(s[i] == '*') {\r\n                sHasStar = true;\r\n            }else{\r\n                sCount++;\r\n            }\r\n        }\r\n        \r\n        bool pHasStar = false;\r\n        int pCount = 0;\r\n        for(int i=0;i<n;i++){\r\n            if(p[i] == '*') {\r\n                pHasStar = true;\r\n            }else{\r\n                pCount++;\r\n            }\r\n        }\r\n        \r\n        if(sHasStar && !pHasStar){\r\n            if(sCount > pCount) return false;\r\n        }\r\n        \r\n        if(!sHasStar && pHasStar){\r\n            if(sCount < pCount) return false;\r\n        }\r\n        \r\n        vector<bool>  A;\r\n\t\tvector<bool>  B;\r\n\t\tvector<bool>  C;\r\n\t\tA.resize(n+1, false);\r\n\t\tB.resize(n+1, false);\r\n\t\tC.resize(m+1, false);\r\n\r\n\t\tA[0] = true;\r\n\t\tfor(int j=0;j<n;j++){\r\n\t\t\tif(p[j] != '*') break;\r\n\t\t\tA[j+1] = true;\r\n        }\r\n\r\n        for(int i=0;i<m;i++){\r\n            if(s[i] != '*') break;\r\n\t\t\tC[i+1] = true;\r\n        }\r\n   \r\n\t\tfor(int i=0;i<m;i++){\r\n\t\t\tB[0] = C[i];\r\n\r\n\t\t\tfor(int j=0;j<n;j++){\r\n\t\t\t\tB[j+1] = false;\r\n\t\t\t\t\r\n\t\t\t\tif(p[j] == '*'){\r\n\t\t\t\t\tB[j+1] = A[j] || B[j] || A[j+1];\r\n\t\t\t\t}else if(p[j] == '?' || s[i] == p[j]){\r\n\t\t\t\t\tB[j+1] = A[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tA = B;\r\n\t\t}\r\n        \r\n        return A[n];\r\n"],[0,"\t}\r\n\r\n  "]],"start1":2987,"start2":2987,"length1":16,"length2":1391}]],"length":6668,"saved":false}
