{"ts":1374870122210,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*Word Search Apr 18 '124672 / 15082\r\nGiven a 2D board and a word, find if the word exists in the grid.\r\n\r\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\r\n\r\nFor example,\r\nGiven board =\r\n\r\n[\r\n  [\"ABCE\"],\r\n  [\"SFCS\"],\r\n  [\"ADEE\"]\r\n]\r\nword = \"ABCCED\", -> returns true,\r\nword = \"SEE\", -> returns true,\r\nword = \"ABCB\", -> returns false.\r\n\r\nAuthor: Wencan Luo\r\nLanguage: C++\r\nDate: 07/25/2013\r\n*/\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n#include<vector>\r\n#include<string>\r\n#include<algorithm>\r\n\r\n#include<map>\r\n//#include<unordered_set>\r\n\r\n#include<queue>\r\n#include<set>\r\n\r\n// Definition for binary tree\r\n struct TreeNode {\r\n     int val;\r\n     TreeNode *left;\r\n     TreeNode *right;\r\n TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n};\r\n \r\nclass Solution {\r\npublic:\r\n\r\n\tbool exist_rec(vector<vector<char> > &board, int x, int y, vector<vector<bool> > &A, string word){\r\n\t\t//find the first one\r\n\t\tif(word.size() == 0) return true;\r\n\r\n\t\tint n = board.size();\r\n\t\tif(n <=0) return false;\r\n\t\tint m = board[0].size();\r\n\r\n\t\tint i=x+1, j=y;\r\n\t\tif(i < n && !A[i][j] && (board[i][j] == word[0])){\r\n\t\t\tA[i][j] = true;\r\n\t\t\tbool found = exist_rec(board, i, j, A, word.substr(1,word.size()-1));\r\n\t\t\tif(found) return true;\r\n\t\t\tA[i][j] = false;\r\n\t\t}\r\n\r\n\t\ti=x-1, j=y;\r\n\t\tif(i >= 0 && !A[i][j] && (board[i][j] == word[0])){\r\n\t\t\tA[i][j] = true;\r\n\t\t\tbool found = exist_rec(board, i, j, A, word.substr(1,word.size()-1));\r\n\t\t\tif(found) return true;\r\n\t\t\tA[i][j] = false;\r\n\t\t}\r\n\r\n\t\ti=x, j=y+1;\r\n\t\tif(j < m && !A[i][j] && (board[i][j] == word[0])){\r\n\t\t\tA[i][j] = true;\r\n\t\t\tbool found = exist_rec(board, i, j, A, word.substr(1,word.size()-1));\r\n\t\t\tif(found) return true;\r\n\t\t\tA[i][j] = false;\r\n\t\t}\r\n\r\n\t\ti=x, j=y-1;\r\n\t\tif(j >= 0 && !A[i][j] && (board[i][j] == word[0])){\r\n\t\t\tA[i][j] = true;\r\n\t\t\tbool found = exist_rec(board, i, j, A, word.substr(1,word.size()-1));\r\n\t\t\tif(found) return true;\r\n\t\t\tA[i][j] = false;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n    bool exist(vector<vector<char> > &board, string word) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n\t\tif(word.size() == 0) return true;\r\n\r\n\t\tint n = board.size();\r\n\t\tif(n <=0) return false;\r\n\t\tint m = board[0].size();\r\n\r\n\t\tvector<vector<bool> > A;\r\n\t\tA.resize(n);\r\n\t\tfor(int i=0;i<n;i++){\r\n\t\t\tA[i].resize(m, false);\r\n\t\t}\r\n\r\n\t\tfor(int i=0;i<n;i++){\r\n\t\t\tfor(int j=0;j<m;j++){\r\n\t\t\t\tif(!A[i][j] && (board[i][j] == word[0])){\r\n\t\t\t\t\tA[i][j] = true;\r\n\t\t\t\t\tbool found = exist_rec(board, i, j, A, word.substr(1,word.size()-1));\r\n\t\t\t\t\tif(found) return true;\r\n\t\t\t\t\tA[i][j] = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n    }\r\n};\r\n\r\nvoid main(){\r\n\tSolution s;\r\n\t\r\n\tchar a[] = \"ab\";\r\n\tvector<char> va;\r\n\tva.push_back('a');\r\n\tva.push_back('b');\r\n\r\n\tvector<vector<char> > vva;\r\n\tvva.push_back(va);\r\n\r\n\tcout << s.exist(vva, \"ba\");\r\n\r\n\tsystem(\"pause\");\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":2973}]],"length":2973}
